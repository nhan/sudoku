// Generated by CoffeeScript 1.4.0
(function() {
  var Sudoku;

  window.Sudoku = Sudoku = Ember.Application.create();

  Sudoku.allValues = function() {
    return [1, 2, 3, 4, 5, 6, 7, 8, 9];
  };

  Sudoku.AllValuesMustAppearConstraint = Ember.Object.extend({
    init: function() {
      var _this = this;
      return this.get('cells').forEach(function(cell) {
        return cell.get('constraints').push(_this);
      });
    },
    processMoreInformation: function() {
      var cells,
        _this = this;
      cells = this.get('cells');
      return Sudoku.allValues().forEach(function(value) {
        var possibleCells;
        possibleCells = cells.filter(function(cell) {
          return cell.get('possibleValues').contains(value);
        });
        if (possibleCells.length === 1) {
          return possibleCells.get('firstObject').setValue(value, _this);
        }
      });
    },
    processLessInformation: function() {
      var _this = this;
      return this.get('cells').forEach(function(cell) {
        return cell.resetValue(_this);
      });
    }
  });

  Sudoku.CannotHaveSameValueConstraint = Ember.Object.extend({
    init: function() {
      var _this = this;
      this.get('constrainedCell').get('constraints').push(this);
      return this.get('relatedCells').forEach(function(cell) {
        return cell.get('constraints').push(_this);
      });
    },
    processMoreInformation: function() {
      var constrainedCell, knownValues, possibleValues, value;
      knownValues = this.get('relatedCells').mapProperty('value');
      possibleValues = Sudoku.allValues().removeObjects(knownValues);
      constrainedCell = this.get('constrainedCell');
      constrainedCell.setPossibleValues(possibleValues, this);
      if (possibleValues.length === 1) {
        value = possibleValues.get('firstObject');
        return constrainedCell.setValue(value, this);
      }
    },
    processLessInformation: function() {
      var constrainedCell;
      constrainedCell = this.get('constrainedCell');
      constrainedCell.resetPossibleValues(this);
      return constrainedCell.resetValue(this);
    }
  });

  Sudoku.Cell = Ember.Object.extend({
    constraints: Ember.computed(function() {
      return [];
    }),
    possibleValues: Ember.computed(function() {
      return Sudoku.allValues();
    }),
    setValue: function(value, informant) {
      if (value !== this.get('value') && this.get('possibleValues').contains(value)) {
        this.set('value', value);
        this.set('valueInformant', informant);
        this.set('possibleValues', [value]);
        this.set('possibleValuesInformant', informant);
        return this.notifyMoreInformation(informant);
      }
    },
    resetValue: function(informant) {
      if (informant === this.get('valueInformant')) {
        this.set('value', void 0);
        this.set('valueInformant', void 0);
        this.set('possibleValues', Sudoku.allValues());
        this.set('possibleValuesInformant', void 0);
        return this.notifyLessInformation(informant);
      }
    },
    setPossibleValues: function(possibleValues, informant) {
      if (possibleValues.length < this.get('possibleValues').length) {
        this.set('possibleValues', possibleValues);
        this.set('possibleValuesInformant', informant);
        return this.notifyMoreInformation(informant);
      }
    },
    resetPossibleValues: function(informant) {
      if (informant === this.get('possibleValuesInformant')) {
        this.set('possibleValues', Sudoku.allValues());
        this.set('possibleValuesInformant', void 0);
        return this.notifyLessInformation(informant);
      }
    },
    notifyMoreInformation: function(informant) {
      var _this = this;
      return Ember.run(function() {
        return _this.get('constraints').forEach(function(constraint) {
          if (constraint !== informant) {
            return constraint.processMoreInformation();
          }
        });
      });
    },
    notifyLessInformation: function(informant) {
      var _this = this;
      Ember.run(function() {
        return _this.get('constraints').forEach(function(constraint) {
          if (constraint !== informant) {
            return constraint.processLessInformation();
          }
        });
      });
      return Ember.run.next(function() {
        return _this.notifyMoreInformation(informant);
      });
    }
  });

  Sudoku.Board = Ember.Object.extend({
    init: function() {
      var x, y, _i, _j,
        _this = this;
      for (x = _i = 0; _i < 9; x = ++_i) {
        for (y = _j = 0; _j < 9; y = ++_j) {
          Sudoku.CannotHaveSameValueConstraint.create({
            constrainedCell: this.cellAt(x, y),
            relatedCells: this.flatten(this.blockAt(x, y)).addObjects(this.rowAt(x, y)).addObjects(this.columnAt(x, y)).without(this.cellAt(x, y))
          });
        }
      }
      this.get('rows').forEach(function(row) {
        return Sudoku.AllValuesMustAppearConstraint.create({
          cells: row
        });
      });
      this.get('columns').forEach(function(column) {
        return Sudoku.AllValuesMustAppearConstraint.create({
          cells: column
        });
      });
      return this.flatten(this.get('blocks')).forEach(function(block) {
        return Sudoku.AllValuesMustAppearConstraint.create({
          cells: _this.flatten(block)
        });
      });
    },
    cells: Ember.computed(function() {
      var x, y, _i, _results;
      _results = [];
      for (x = _i = 0; _i < 9; x = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; _j < 9; y = ++_j) {
            _results1.push(Sudoku.Cell.create({
              x: x,
              y: y
            }));
          }
          return _results1;
        })());
      }
      return _results;
    }),
    cellAt: function(x, y) {
      return this.get('cells')[x][y];
    },
    flatten: function(block) {
      return block.reduce((function(a, b) {
        return a.addObjects(b);
      }), []);
    },
    blocks: Ember.computed(function() {
      var x, y, _i, _results;
      _results = [];
      for (x = _i = 0; _i < 9; x = _i += 3) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; _j < 9; y = _j += 3) {
            _results1.push(this.blockAt(x, y));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    }),
    blockAt: function(x, y) {
      var i, j, _i, _results;
      _results = [];
      for (i = _i = 0; _i < 3; i = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (j = _j = 0; _j < 3; j = ++_j) {
            _results1.push(this.cellAt((x - (x % 3)) + i, (y - (y % 3)) + j));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    },
    columns: Ember.computed(function() {
      var y, _i, _results;
      _results = [];
      for (y = _i = 0; _i < 9; y = ++_i) {
        _results.push(this.columnAt(0, y));
      }
      return _results;
    }),
    columnAt: function(x, y) {
      var row, _i, _results;
      _results = [];
      for (row = _i = 0; _i < 9; row = ++_i) {
        _results.push(this.cellAt(row, y));
      }
      return _results;
    },
    rows: Ember.computed(function() {
      var x, _i, _results;
      _results = [];
      for (x = _i = 0; _i < 9; x = ++_i) {
        _results.push(this.rowAt(x, 0));
      }
      return _results;
    }),
    rowAt: function(x, y) {
      var column, _i, _results;
      _results = [];
      for (column = _i = 0; _i < 9; column = ++_i) {
        _results.push(this.cellAt(x, column));
      }
      return _results;
    }
  });

  Sudoku.IndexRoute = Ember.Route.extend({
    model: function() {
      return Sudoku.Board.create();
    }
  });

  Sudoku.CellView = Ember.View.extend({
    classNames: ['sudoku_cell'],
    classNameBindings: ['valueType', 'classId', 'noPossibleValues:impossible:'],
    templateName: 'sudoku_cell',
    attributeBindings: ['tabindex'],
    tabindex: 0,
    possibleValues: Ember.computed(function() {
      return this.get('cell.possibleValues').join(' ');
    }).property('cell.possibleValues'),
    getId: function(x, y) {
      x = Math.min(Math.max(x, 0), 8);
      y = Math.min(Math.max(y, 0), 8);
      return "cell_" + x + "_" + y;
    },
    classId: Ember.computed(function() {
      return this.getId(this.get('cell.x'), this.get('cell.y'));
    }),
    valueType: Ember.computed(function() {
      if (this.get('conflictingValue')) {
        return 'conflict';
      } else if (this.get('cell.value') && this.get('cell.valueInformant') !== 'user') {
        return 'computed';
      }
    }).property('cell.value', 'cell.valueInformant', 'conflictingValue'),
    noPossibleValues: Ember.computed(function() {
      return this.get('cell.possibleValues').length === 0;
    }).property('cell.possibleValues'),
    value: Ember.computed(function() {
      var conflictingValue;
      conflictingValue = this.get('conflictingValue');
      if (conflictingValue != null) {
        return conflictingValue;
      } else {
        return this.get('cell.value');
      }
    }).property('cell.value', 'conflictingValue'),
    keyPress: function(event) {
      var char, number;
      event.preventDefault();
      char = String.fromCharCode(event.which);
      if ("123456789".indexOf(char) >= 0) {
        number = parseInt(char);
        if (this.get('cell.possibleValues').contains(number)) {
          this.get('cell').setValue(number, 'user');
          return this.set('conflictingValue', void 0);
        } else {
          return this.set('conflictingValue', number);
        }
      }
    },
    keyDown: function(event) {
      if ([8, 45, 37, 38, 39, 40].contains(event.which)) {
        event.preventDefault();
      }
      switch (event.which) {
        case 8:
        case 45:
          this.get('cell').resetValue('user');
          return this.set('conflictingValue', void 0);
        case 37:
          return $("." + (this.getId(this.get('cell.x'), this.get('cell.y') - 1))).focus();
        case 38:
          return $("." + (this.getId(this.get('cell.x') - 1, this.get('cell.y')))).focus();
        case 39:
          return $("." + (this.getId(this.get('cell.x'), this.get('cell.y') + 1))).focus();
        case 40:
          return $("." + (this.getId(this.get('cell.x') + 1, this.get('cell.y')))).focus();
      }
    },
    focusOut: function(event) {
      return this.set('conflictingValue', void 0);
    }
  });

}).call(this);
